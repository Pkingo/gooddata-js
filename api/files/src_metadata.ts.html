---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/admin.html">admin</a></li>
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/DataLayer.html">DataLayer</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/admin.html">admin</a></li>
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/DataLayer.html">DataLayer</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v8.0.0</span>
                        <h1 class="file-heading">File: src/metadata.ts</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // Copyright (C) 2007-2014, GoodData(R) Corporation. All rights reserved.
                        import {
                            isPlainObject,
                            get as _get,
                            chunk,
                            flatten,
                            pick
                        } from &#x27;lodash&#x27;;
                        import { AFM } from &#x27;@gooddata/typings&#x27;;
                        import { getIn, handlePolling, queryString } from &#x27;./util&#x27;;
                        import { ApiResponse, ApiResponseError, XhrModule } from &#x27;./xhr&#x27;;
                        
                        import {
                            IGetObjectsByQueryOptions, IGetObjectUsingOptions, SortDirection
                        } from &#x27;./interfaces&#x27;;
                        
                        export interface IValidElementsOptions {
                            limit?: number;
                            offset?: number;
                            order?: SortDirection;
                            filter?: string;
                            prompt?: string;
                            uris?: string[];
                            complement?: boolean;
                            includeTotalCountWithoutFilters?: boolean;
                            restrictiveDefinition?: string;
                            restrictiveDefinitionContent?: object;
                            afm?: AFM.IAfm;
                        }
                        
                        /**
                         * Functions for working with metadata objects
                         *
                         * @class metadata
                         * @module metadata
                         */
                        export class MetadataModule {
                            constructor(private xhr: XhrModule) {}
                        
                            /**
                             * Load all objects with given uris
                             * (use bulk loading instead of getting objects one by one)
                             *
                             * @method getObjects
                             * @param {String} projectId id of the project
                             * @param {Array} objectUris array of uris for objects to be loaded
                             * @return {Array} array of loaded elements
                             */
                            public getObjects(projectId: string, objectUris: string[]): any {
                                const LIMIT = 50;
                                const uri = &#x60;/gdc/md/${projectId}/objects/get&#x60;;
                        
                                const objectsUrisChunks = chunk(objectUris, LIMIT);
                        
                                const promises = objectsUrisChunks.map((objectUrisChunk) =&gt; {
                                    const body = {
                                        get: {
                                            items: objectUrisChunk
                                        }
                                    };
                        
                                    return this.xhr.post(uri, { body })
                                        .then((r: ApiResponse) =&gt; {
                                            if (!r.response.ok) {
                                                throw new ApiResponseError(r.response.statusText, r.response, r.responseBody);
                                            }
                        
                                            return r.getData();
                                        })
                                        .then((result: any) =&gt; _get(result, [&#x27;objects&#x27;, &#x27;items&#x27;]));
                                });
                        
                                return Promise.all(promises).then(flatten);
                            }
                        
                            /**
                             * Loads all objects by query (fetches all pages, one by one)
                             *
                             * @method getObjectsByQuery
                             * @param {String} projectId id of the project
                             * @param {Object} options (see https://developer.gooddata.com/api endpoint: /gdc/md/{project_id}/objects/query)
                             *        - category {String} for example &#x27;dataSets&#x27; or &#x27;projectDashboard&#x27;
                             *        - mode {String} &#x27;enriched&#x27; or &#x27;raw&#x27;
                             *        - author {String} the URI of the author of the metadata objects
                             *        - limit {number} default is 50 (also maximum)
                             *        - deprecated {boolean} show also deprecated objects
                             * @return {Promise&lt;Array&gt;} array of returned objects
                             */
                            public getObjectsByQuery(projectId: string, options: IGetObjectsByQueryOptions): Promise&lt;any[]&gt; {
                                const getOnePage = (uri: string, items: any[] = []): Promise&lt;any&gt; =&gt; {
                                    return this.xhr.get(uri)
                                        .then((r: ApiResponse) =&gt; r.getData())
                                        .then(({ objects }: any) =&gt; {
                                            items.push(...objects.items);
                                            const nextUri = objects.paging.next;
                                            return nextUri ? getOnePage(nextUri, items) : items;
                                        });
                                };
                        
                                const deprecated = options.deprecated ? { deprecated: 1 } : {};
                                const uri = &#x60;/gdc/md/${projectId}/objects/query&#x60;;
                                const query = pick({ limit: 50, ...options, ...deprecated },
                                    [&#x27;category&#x27;, &#x27;mode&#x27;, &#x27;author&#x27;, &#x27;limit&#x27;, &#x27;deprecated&#x27;]);
                                return getOnePage(uri + queryString(query));
                            }
                        
                            /**
                             * Get MD objects from using2 resource. Include only objects of given types
                             * and take care about fetching only nearest objects if requested.
                             *
                             * @method getObjectUsing
                             * @param {String} projectId id of the project
                             * @param {String} uri uri of the object for which dependencies are to be found
                             * @param {Object} options objects with options:
                             *        - types {Array} array of strings with object types to be included
                             *        - nearest {Boolean} whether to include only nearest dependencies
                             * @return {jQuery promise} promise promise once resolved returns an array of
                             *         entries returned by using2 resource
                             */
                            public getObjectUsing(projectId: string, uri: string, options: IGetObjectUsingOptions = {}) {
                                const { types = [], nearest = false } = options;
                                const resourceUri = &#x60;/gdc/md/${projectId}/using2&#x60;;
                        
                                const body = {
                                    inUse: {
                                        uri,
                                        types,
                                        nearest: nearest ? 1 : 0
                                    }
                                };
                        
                                return this.xhr.post(resourceUri, { body })
                                    .then((r: ApiResponse) =&gt; {
                                        if (!r.response.ok) {
                                            throw new ApiResponseError(r.response.statusText, r.response, r.getData());
                                        }
                        
                                        return r.getData();
                                    })
                                    .then((result: any) =&gt; result.entries);
                            }
                        
                            /**
                             * Get MD objects from using2 resource. Include only objects of given types
                             * and take care about fetching only nearest objects if requested.
                             *
                             * @method getObjectUsingMany
                             * @param {String} projectId id of the project
                             * @param {Array} uris uris of objects for which dependencies are to be found
                             * @param {Object} options objects with options:
                             *        - types {Array} array of strings with object types to be included
                             *        - nearest {Boolean} whether to include only nearest dependencies
                             * @return {jQuery promise} promise promise once resolved returns an array of
                             *         entries returned by using2 resource
                             */
                            public getObjectUsingMany(projectId: string, uris: string[], options: IGetObjectUsingOptions = {}): Promise&lt;any&gt; {
                                const { types = [], nearest = false } = options;
                                const resourceUri = &#x60;/gdc/md/${projectId}/using2&#x60;;
                        
                                const body = {
                                    inUseMany: {
                                        uris,
                                        types,
                                        nearest: nearest ? 1 : 0
                                    }
                                };
                        
                                return this.xhr.post(resourceUri, { body })
                                    .then((r: ApiResponse) =&gt; {
                                        if (!r.response.ok) {
                                            throw new ApiResponseError(r.response.statusText, r.response, r.getData());
                                        }
                        
                                        return r.getData();
                                    }).
                                    then((result: any) =&gt; result.useMany);
                            }
                        
                            /**
                             * Returns all visualizationObjects metadata in a project specified by projectId param
                             *
                             * @method getVisualizations
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of visualization objects metadata
                             */
                            public getVisualizations(projectId: string): Promise&lt;any&gt; {
                                return this.xhr.get(&#x60;/gdc/md/${projectId}/query/visualizationobjects&#x60;)
                                    .then((apiResponse: ApiResponse) =&gt;
                                        (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response))
                                    .then(getIn(&#x27;query.entries&#x27;));
                            }
                        
                            /**
                             * Returns all attributes in a project specified by projectId param
                             *
                             * @method getAttributes
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of attribute objects
                             */
                            public getAttributes(projectId: string): Promise&lt;any&gt; {
                                return this.xhr.get(&#x60;/gdc/md/${projectId}/query/attributes&#x60;)
                                    .then(
                                        (apiResponse: ApiResponse) =&gt; (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response)
                                    )
                                    .then(getIn(&#x27;query.entries&#x27;));
                            }
                        
                            /**
                             * Returns all dimensions in a project specified by projectId param
                             *
                             * @method getDimensions
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of dimension objects
                             * @see getFolders
                             */
                            public getDimensions(projectId: string): Promise&lt;any&gt; {
                                return this.xhr.get(&#x60;/gdc/md/${projectId}/query/dimensions&#x60;)
                                    .then(
                                        (apiResponse: ApiResponse) =&gt; (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response)
                                    )
                                    .then(getIn(&#x27;query.entries&#x27;));
                            }
                        
                            /**
                             * Returns project folders. Folders can be of specific types and you can specify
                             * the type you need by passing and optional &#x60;type&#x60; parameter
                             *
                             * @method getFolders
                             * @param {String} projectId - Project identifier
                             * @param {String} type - Optional, possible values are &#x60;metric&#x60;, &#x60;fact&#x60;, &#x60;attribute&#x60;
                             * @return {Array} An array of dimension objects
                             */
                            public getFolders(projectId: string, type: string) { // TODO enum?
                                const getFolderEntries = (pId: string, t: string) =&gt; {
                                    const typeURL = t ? &#x60;?type=${t}&#x60; : &#x27;&#x27;;
                        
                                    return this.xhr.get(&#x60;/gdc/md/${pId}/query/folders${typeURL}&#x60;)
                                        .then((r =&gt; r.getData()))
                                        .then(getIn(&#x27;query.entries&#x27;));
                                };
                        
                                switch (type) {
                                    case &#x27;fact&#x27;:
                                    case &#x27;metric&#x27;:
                                        return getFolderEntries(projectId, type);
                                    case &#x27;attribute&#x27;:
                                        return this.getDimensions(projectId);
                                    default:
                                        return Promise.all([
                                            getFolderEntries(projectId, &#x27;fact&#x27;),
                                            getFolderEntries(projectId, &#x27;metric&#x27;),
                                            this.getDimensions(projectId)
                                        ])
                                        .then(([facts, metrics, attributes]) =&gt; {
                                            return { fact: facts, metric: metrics, attribute: attributes };
                                        });
                                }
                            }
                        
                            /**
                             * Returns all facts in a project specified by the given projectId
                             *
                             * @method getFacts
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of fact objects
                             */
                            public getFacts(projectId: string): Promise&lt;any&gt; {
                                return this.xhr.get(&#x60;/gdc/md/${projectId}/query/facts&#x60;)
                                    .then(
                                        (apiResponse: ApiResponse) =&gt; (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response)
                                    )
                                    .then(getIn(&#x27;query.entries&#x27;));
                            }
                        
                            /**
                             * Returns all metrics in a project specified by the given projectId
                             *
                             * @method getMetrics
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of metric objects
                             */
                            public getMetrics(projectId: string): Promise&lt;any&gt; {
                                return this.xhr.get(&#x60;/gdc/md/${projectId}/query/metrics&#x60;)
                                    .then(
                                        (apiResponse: ApiResponse) =&gt; (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response)
                                    )
                                    .then(getIn(&#x27;query.entries&#x27;));
                            }
                        
                            /**
                             * Returns all metrics that are reachable (with respect to ldm of the project
                             * specified by the given projectId) for given attributes
                             *
                             * @method getAvailableMetrics
                             * @param {String} projectId - Project identifier
                             * @param {Array} attrs - An array of attribute uris for which we want to get
                             * availabale metrics
                             * @return {Array} An array of reachable metrics for the given attrs
                             * @see getAvailableAttributes
                             * @see getAvailableFacts
                             */
                            public getAvailableMetrics(projectId: string, attrs: string[] = []): Promise&lt;any&gt; {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/availablemetrics&#x60;, { body: attrs })
                                    .then(
                                        (apiResponse: ApiResponse) =&gt; (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response)
                                    )
                                    .then((data: any) =&gt; data.entries);
                            }
                        
                            /**
                             * Returns all attributes that are reachable (with respect to ldm of the project
                             * specified by the given projectId) for given metrics (also called as drillCrossPath)
                             *
                             * @method getAvailableAttributes
                             * @param {String} projectId - Project identifier
                             * @param {Array} metrics - An array of metric uris for which we want to get
                             * availabale attributes
                             * @return {Array} An array of reachable attributes for the given metrics
                             * @see getAvailableMetrics
                             * @see getAvailableFacts
                             */
                            public getAvailableAttributes(projectId: string, metrics: string[] = []): Promise&lt;any&gt; {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/drillcrosspaths&#x60;, { body: metrics })
                                    .then(apiResponse =&gt; (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response))
                                    .then((r: any) =&gt; r.drillcrosspath.links);
                            }
                        
                            /**
                             * Returns all attributes that are reachable (with respect to ldm of the project
                             * specified by the given projectId) for given metrics (also called as drillCrossPath)
                             *
                             * @method getAvailableFacts
                             * @param {String} projectId - Project identifier
                             * @param {Array} items - An array of metric or attribute uris for which we want to get
                             * availabale facts
                             * @return {Array} An array of reachable facts for the given items
                             * @see getAvailableAttributes
                             * @see getAvailableMetrics
                             */
                            public getAvailableFacts(projectId: string, items: string[] = []): Promise&lt;any&gt; {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/availablefacts&#x60;, { body: items })
                                    .then((r: ApiResponse) =&gt; (r.response.ok ? r.getData() : r.response)).then((r: any) =&gt; r.entries);
                            }
                        
                            /**
                             * Get details of a metadata object specified by its uri
                             *
                             * @method getObjectDetails
                             * @param uri uri of the metadata object for which details are to be retrieved
                             * @return {Object} object details
                             */
                            public getObjectDetails(uri: string): Promise&lt;any&gt; {
                                return this.xhr.get(uri).then((r: ApiResponse) =&gt; r.getData());
                            }
                        
                            /**
                             * Get folders with items.
                             * Returns array of folders, each having a title and items property which is an array of
                             * corresponding items. Each item is either a metric or attribute, keeping its original
                             * verbose structure.
                             *
                             * @method getFoldersWithItems
                             * @param {String} type type of folders to return
                             * @return {Array} Array of folder object, each containing title and
                             * corresponding items.
                             */
                            public getFoldersWithItems(projectId: string, type: string) {
                                // fetch all folders of given type and process them
                                return this.getFolders(projectId, type).then((folders) =&gt; {
                                    // Helper public to get details for each metric in the given
                                    // array of links to the metadata objects representing the metrics.
                                    // @return the array of promises
                                    const getMetricItemsDetails = (array: any[]) =&gt; {
                                        return Promise.all(array.map(this.getObjectDetails)).then((metricArgs) =&gt; {
                                            return metricArgs.map((item: any) =&gt; item.metric);
                                        });
                                    };
                        
                                    // helper mapBy function
                                    function mapBy(array: any[], key: string) {
                                        return array.map((item: any) =&gt; {
                                            return item[key];
                                        });
                                    }
                        
                                    // helper for sorting folder tree structure
                                    // sadly @returns void (sorting == mutating array in js)
                                    const sortFolderTree = (structure: any[]) =&gt; {
                                        structure.forEach((folder) =&gt; {
                                            folder.items.sort((a: any, b: any) =&gt; {
                                                if (a.meta.title &lt; b.meta.title) {
                                                    return -1;
                                                } else if (a.meta.title &gt; b.meta.title) {
                                                    return 1;
                                                }
                        
                                                return 0;
                                            });
                                        });
                                        structure.sort((a, b) =&gt; {
                                            if (a.title &lt; b.title) {
                                                return -1;
                                            } else if (a.title &gt; b.title) {
                                                return 1;
                                            }
                        
                                            return 0;
                                        });
                                    };
                        
                                    const foldersLinks = mapBy(folders, &#x27;link&#x27;);
                                    const foldersTitles = mapBy(folders, &#x27;title&#x27;);
                        
                                    // fetch details for each folder
                                    return Promise.all(foldersLinks.map(this.getObjectDetails)).then((folderDetails) =&gt; {
                                        // if attribute, just parse everything from what we&#x27;ve received
                                        // and resolve. For metrics, lookup again each metric to get its
                                        // identifier. If passing unsupported type, reject immediately.
                                        if (type === &#x27;attribute&#x27;) {
                                            // get all attributes, subtract what we have and add rest in unsorted folder
                                            return this.getAttributes(projectId).then((attributes) =&gt; {
                                                // get uris of attributes which are in some dimension folders
                                                const attributesInFolders: any[] = [];
                                                folderDetails.forEach((fd: any) =&gt; {
                                                    fd.dimension.content.attributes.forEach((attr: any) =&gt; {
                                                        attributesInFolders.push(attr.meta.uri);
                                                    });
                                                });
                                                // unsortedUris now contains uris of all attributes which aren&#x27;t in a folder
                                                const unsortedUris =
                                                    attributes
                                                        .filter((item: any) =&gt; attributesInFolders.indexOf(item.link) === -1)
                                                        .map((item: any) =&gt; item.link);
                                                // now get details of attributes in no folders
                                                return Promise.all(unsortedUris.map(this.getObjectDetails))
                                                    .then((unsortedAttributeArgs) =&gt; { // TODO add map to r.json
                                                        // get unsorted attribute objects
                                                        const unsortedAttributes = unsortedAttributeArgs.map((attr: any) =&gt; attr.attribute);
                                                        // create structure of folders with attributes
                                                        const structure = folderDetails.map((folderDetail: any) =&gt; {
                                                            return {
                                                                title: folderDetail.dimension.meta.title,
                                                                items: folderDetail.dimension.content.attributes
                                                            };
                                                        });
                                                        // and append &quot;Unsorted&quot; folder with attributes to the structure
                                                        structure.push({
                                                            title: &#x27;Unsorted&#x27;,
                                                            items: unsortedAttributes
                                                        });
                                                        sortFolderTree(structure);
                        
                                                        return structure;
                                                    });
                                            });
                                        } else if (type === &#x27;metric&#x27;) {
                                            const entriesLinks = folderDetails.map((entry: any) =&gt; mapBy(entry.folder.content.entries, &#x27;link&#x27;));
                                            // get all metrics, subtract what we have and add rest in unsorted folder
                                            return this.getMetrics(projectId).then((metrics) =&gt; {
                                                // get uris of metrics which are in some dimension folders
                                                const metricsInFolders: string[] = [];
                                                folderDetails.forEach((fd: any) =&gt; {
                                                    fd.folder.content.entries.forEach((metric: any) =&gt; {
                                                        metricsInFolders.push(metric.link);
                                                    });
                                                });
                                                // unsortedUris now contains uris of all metrics which aren&#x27;t in a folder
                                                const unsortedUris =
                                                    metrics
                                                        .filter((item: any) =&gt; metricsInFolders.indexOf(item.link) === -1)
                                                        .map((item: any) =&gt; item.link);
                        
                                                // sadly order of parameters of concat matters! (we want unsorted last)
                                                entriesLinks.push(unsortedUris);
                        
                                                // now get details of all metrics
                                                return Promise.all(entriesLinks.map(linkArray =&gt; getMetricItemsDetails(linkArray)))
                                                    .then((tree) =&gt; { // TODO add map to r.json
                                                        // all promises resolved, i.e. details for each metric are available
                                                        const structure = tree.map((treeItems, idx) =&gt; {
                                                            // if idx is not in foldes list than metric is in &quot;Unsorted&quot; folder
                                                            return {
                                                                title: (foldersTitles[idx] || &#x27;Unsorted&#x27;),
                                                                items: treeItems
                                                            };
                                                        });
                                                        sortFolderTree(structure);
                                                        return structure;
                                                    });
                                            });
                                        }
                        
                                        return Promise.reject(null);
                                    });
                                });
                            }
                        
                            /**
                             * Get identifier of a metadata object identified by its uri
                             *
                             * @method getObjectIdentifier
                             * @param uri uri of the metadata object for which the identifier is to be retrieved
                             * @return {String} object identifier
                             */
                            public getObjectIdentifier(uri: string) {
                                function idFinder(obj: any) { // TODO
                                    if (obj.attribute) {
                                        return obj.attribute.content.displayForms[0].meta.identifier;
                                    } else if (obj.dimension) {
                                        return obj.dimension.content.attributes.content.displayForms[0].meta.identifier;
                                    } else if (obj.metric) {
                                        return obj.metric.meta.identifier;
                                    }
                        
                                    throw Error(&#x27;Unknown object!&#x27;);
                                }
                        
                                if (!isPlainObject(uri)) {
                                    return this.getObjectDetails(uri).then(data =&gt; idFinder(data));
                                }
                                return Promise.resolve(idFinder(uri));
                            }
                        
                            /**
                             * Get uri of an metadata object, specified by its identifier and project id it belongs to
                             *
                             * @method getObjectUri
                             * @param {string} projectId id of the project
                             * @param identifier identifier of the metadata object
                             * @return {String} uri of the metadata object
                             */
                            public getObjectUri(projectId: string, identifier: string) {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                    body: {
                                        identifierToUri: [identifier]
                                    }
                                }).then((r: ApiResponse) =&gt; {
                                    const data = r.getData();
                                    const found = data.identifiers.find((pair: any) =&gt; pair.identifier === identifier);
                        
                                    if (found) {
                                        return found.uri;
                                    }
                        
                                    throw new ApiResponseError(
                                        &#x60;Object with identifier ${identifier} not found in project ${projectId}&#x60;,
                                        r.response,
                                        r.responseBody
                                    );
                                });
                            }
                        
                            /**
                             * Get uris specified by identifiers
                             *
                             * @method getUrisFromIdentifiers
                             * @param {String} projectId id of the project
                             * @param {Array} identifiers identifiers of the metadata objects
                             * @return {Array} array of identifier + uri pairs
                             */
                            public getUrisFromIdentifiers(projectId: string, identifiers: string[]) {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                    body: {
                                        identifierToUri: identifiers
                                    }
                                }).then(((r: ApiResponse) =&gt; r.getData())).then((data) =&gt; {
                                    return data.identifiers;
                                });
                            }
                        
                            /**
                             * Get identifiers specified by uris
                             *
                             * @method getIdentifiersFromUris
                             * @param {String} projectId id of the project
                             * @param {Array} uris of the metadata objects
                             * @return {Array} array of identifier + uri pairs
                             */
                            public getIdentifiersFromUris(projectId: string, uris: string[]) {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                    body: {
                                        uriToIdentifier: uris
                                    }
                                }).then(((r: ApiResponse) =&gt; r.getData())).then((data) =&gt; {
                                    return data.identifiers;
                                });
                            }
                        
                            /**
                             * Get attribute elements with their labels and uris.
                             *
                             * @param {String} projectId id of the project
                             * @param {String} labelUri uri of the label (display form)
                             * @param {Array&lt;String&gt;} patterns elements labels/titles (for EXACT mode), or patterns (for WILD mode)
                             * @param {(&#x27;EXACT&#x27;|&#x27;WILD&#x27;)} mode match mode, currently only EXACT supported
                             * @return {Array} array of elementLabelUri objects
                             */
                            public translateElementLabelsToUris(projectId: string, labelUri: string, patterns: string[], mode = &#x27;EXACT&#x27;) {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/labels&#x60;, {
                                    body: {
                                        elementLabelToUri: [
                                            {
                                                labelUri,
                                                mode,
                                                patterns
                                            }
                                        ]
                                    }
                                }).then((r: ApiResponse) =&gt; (r.response.ok ? _get(r.getData(), &#x27;elementLabelUri&#x27;) : r.response));
                            }
                        
                            /**
                             * Get valid elements of an attribute, specified by its identifier and project id it belongs to
                             *
                             * @method getValidElements
                             * @param {string} projectId id of the project
                             * @param id display form id of the metadata object
                             * @param {Object} options objects with options:
                             *      - limit {Number}
                             *      - offset {Number}
                             *      - order {String} &#x27;asc&#x27; or &#x27;desc&#x27;
                             *      - filter {String}
                             *      - prompt {String}
                             *      - uris {Array}
                             *      - complement {Boolean}
                             *      - includeTotalCountWithoutFilters {Boolean}
                             *      - restrictiveDefinition {String}
                             *      - afm {Object}
                             * @return {Object} ValidElements response with:
                             *      - items {Array} elements
                             *      - paging {Object}
                             *      - elementsMeta {Object}
                             */
                            public getValidElements(projectId: string, id: string, options: IValidElementsOptions = {}) {
                                const query = pick(options, [&#x27;limit&#x27;, &#x27;offset&#x27;, &#x27;order&#x27;, &#x27;filter&#x27;, &#x27;prompt&#x27;]);
                                const queryParams = queryString(query);
                                const pickedOptions = pick(options, [
                                    &#x27;uris&#x27;, &#x27;complement&#x27;, &#x27;includeTotalCountWithoutFilters&#x27;, &#x27;restrictiveDefinition&#x27;
                                ]);
                                const { afm } = options;
                        
                                const getRequestBodyWithReportDefinition =
                                    () =&gt; this.xhr
                                        .post(&#x60;/gdc/app/projects/${projectId}/executeAfm/debug&#x60;, {
                                            body: {
                                                execution: {
                                                    afm
                                                }
                                            }
                                        })
                                        .then(response =&gt; response.getData())
                                        .then(reportDefinitionResult =&gt; ({
                                            ...pickedOptions,
                                            restrictiveDefinitionContent: reportDefinitionResult.reportDefinition.content
                                        }));
                        
                                const getOptions = afm ? getRequestBodyWithReportDefinition : () =&gt; Promise.resolve(pickedOptions);
                        
                                return getOptions()
                                    .then(requestBody =&gt; this.xhr
                                        .post(&#x60;/gdc/md/${projectId}/obj/${id}/validElements${queryParams}&#x60;.replace(/\?$/, &#x27;&#x27;), {
                                            body: {
                                                validElementsRequest: requestBody
                                            }
                                        })
                                        .then(response =&gt; response.getData())
                                    );
                            }
                        
                            /**
                             * Delete object
                             *
                             * @experimental
                             * @method deleteObject
                             * @param {String} uri of the object to be deleted
                             */
                            public deleteObject(uri: string) {
                                return this.xhr.del(uri);
                            }
                        
                            /**
                             * Create object
                             *
                             * @experimental
                             * @method createObject
                             * @param {String} projectId
                             * @param {String} obj object definition
                             */
                            public createObject(projectId: string, obj: any) {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/obj?createAndGet=true&#x60;, {
                                    body: obj
                                }).then(((r: ApiResponse) =&gt; r.getData()));
                            }
                        
                            /**
                             * LDM manage
                             *
                             * @experimental
                             * @method ldmManage
                             * @param {String} projectId
                             * @param {String} maql
                             * @param {Object} options for polling (maxAttempts, pollStep)
                             */
                            public ldmManage(projectId: string, maql: string, options = {}) {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/ldm/manage2&#x60;, { body: { manage: { maql } } })
                                    .then(((r: ApiResponse) =&gt; r.getData()))
                                    .then((response: any) =&gt; {
                                        const manageStatusUri = response.entries[0].link;
                                        return handlePolling(this.xhr.get.bind(this.xhr), manageStatusUri, this.isTaskFinished, options);
                                    })
                                    .then(this.checkStatusForError);
                            }
                        
                            /**
                             * ETL pull
                             *
                             * @experimental
                             * @method etlPull
                             * @param {String} projectId
                             * @param {String} uploadsDir
                             * @param {Object} options for polling (maxAttempts, pollStep)
                             */
                            public etlPull(projectId: string, uploadsDir: string, options = {}) {
                                return this.xhr.post(&#x60;/gdc/md/${projectId}/etl/pull2&#x60;, { body: { pullIntegration: uploadsDir } })
                                    .then(((r: ApiResponse) =&gt; r.getData()))
                                    .then((response: any) =&gt; {
                                        const etlPullStatusUri = response.pull2Task.links.poll;
                                        return handlePolling(this.xhr.get.bind(this.xhr), etlPullStatusUri, this.isTaskFinished, options);
                                    })
                                    .then(this.checkStatusForError);
                            }
                        
                            private isTaskFinished(task: any) {
                                const taskState = task.wTaskStatus.status;
                                return taskState === &#x27;OK&#x27; || taskState === &#x27;ERROR&#x27;;
                            }
                        
                            private checkStatusForError(response: any) {
                                if (response.wTaskStatus.status === &#x27;ERROR&#x27;) {
                                    return Promise.reject(response);
                                }
                                return response;
                            }
                        }
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

