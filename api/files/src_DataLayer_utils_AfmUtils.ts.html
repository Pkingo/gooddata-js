---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/admin.html">admin</a></li>
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/DataLayer.html">DataLayer</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/admin.html">admin</a></li>
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/DataLayer.html">DataLayer</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v8.0.0</span>
                        <h1 class="file-heading">File: src/DataLayer/utils/AfmUtils.ts</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // (C) 2007-2018 GoodData Corporation
                        import flatMap = require(&#x27;lodash/flatMap&#x27;);
                        import compact = require(&#x27;lodash/compact&#x27;);
                        import { AFM } from &#x27;@gooddata/typings&#x27;;
                        
                        export const ALL_TIME_GRANULARITY = &#x27;ALL_TIME_GRANULARITY&#x27;;
                        
                        export interface INormalizedAFM {
                            attributes: AFM.IAttribute[];
                            measures: AFM.IMeasure[];
                            filters: AFM.CompatibilityFilter[];
                            nativeTotals: AFM.INativeTotalItem[];
                        }
                        
                        /**
                         * Unwraps measure object
                         *
                         * @method unwrapSimpleMeasure
                         * @param {AFM.IMeasure} item
                         * @returns {AFM.ISimpleMeasure}
                         */
                        export function unwrapSimpleMeasure(item: AFM.IMeasure): AFM.ISimpleMeasure {
                            return (item.definition as AFM.ISimpleMeasureDefinition).measure;
                        }
                        
                        /**
                         * Unwraps popMeasure object
                         *
                         * @method unwrapPoPMeasure
                         * @param {AFM.IMeasure} item
                         * @returns {AFM.IPopMeasure}
                         */
                        export function unwrapPoPMeasure(item: AFM.IMeasure): AFM.IPopMeasure {
                            return (item.definition as AFM.IPopMeasureDefinition).popMeasure;
                        }
                        
                        /**
                         * Unwraps previousPeriodMeasure object
                         *
                         * @method unwrapPreviousPeriodMeasure
                         * @param {AFM.IMeasure} item
                         * @returns {AFM.IPreviousPeriodMeasure}
                         */
                        export function unwrapPreviousPeriodMeasure(item: AFM.IMeasure): AFM.IPreviousPeriodMeasure {
                            return (item.definition as AFM.IPreviousPeriodMeasureDefinition).previousPeriodMeasure;
                        }
                        
                        /**
                         * Normalize AFM
                         *
                         * @method normalizeAfm
                         * @param {AFM.IAfm} afm
                         * @returns {INormalizedAFM}
                         */
                        export function normalizeAfm(afm: AFM.IAfm): INormalizedAFM {
                            return {
                                attributes: afm.attributes || [],
                                measures: afm.measures || [],
                                filters: afm.filters || [],
                                nativeTotals: afm.nativeTotals || []
                            };
                        }
                        
                        /**
                         * Returns true if measure is a simple measure
                         *
                         * @method isSimpleMeasure
                         * @param {AFM.IMeasure} item
                         * @returns {boolean}
                         */
                        export function isSimpleMeasure(item: AFM.IMeasure): boolean {
                            return !!unwrapSimpleMeasure(item);
                        }
                        
                        /**
                         * Returns true if measure is PeriodOverPeriod
                         *
                         * @method isPoP
                         * @param {AFM.IMeasure} item
                         * @returns {boolean}
                         */
                        export function isPoP(item: AFM.IMeasure): boolean {
                            return !!unwrapPoPMeasure(item);
                        }
                        
                        /**
                         * Returns true if measure is previous period measure
                         *
                         * @method isPreviousPeriodMeasure
                         * @param {AFM.IMeasure} item
                         * @returns {boolean}
                         */
                        export function isPreviousPeriodMeasure(item: AFM.IMeasure): boolean {
                            return !!unwrapPreviousPeriodMeasure(item);
                        }
                        
                        /**
                         * Returns true if filter is attributeFilter
                         *
                         * @method isAttributeFilter
                         * @param {AFM.FilterItem} filter
                         * @returns {boolean}
                         */
                        export function isAttributeFilter(filter: AFM.FilterItem): filter is AFM.AttributeFilterItem {
                            return !!(filter as AFM.IPositiveAttributeFilter).positiveAttributeFilter ||
                                !!(filter as AFM.INegativeAttributeFilter).negativeAttributeFilter;
                        }
                        
                        /**
                         * Returns true if filter is dateFilter
                         *
                         * @method isDateFilter
                         * @param {AFM.CompatibilityFilter} filter
                         * @returns {boolean}
                         */
                        export function isDateFilter(filter: AFM.CompatibilityFilter): filter is AFM.DateFilterItem {
                            return !!(filter as AFM.IAbsoluteDateFilter).absoluteDateFilter ||
                                !!(filter as AFM.IRelativeDateFilter).relativeDateFilter;
                        }
                        
                        /**
                         * Returns true if measure has dateFilters
                         *
                         * @method hasMetricDateFilters
                         * @param {INormalizedAFM} normalizedAfm
                         * @returns {boolean}
                         */
                        export function hasMetricDateFilters(normalizedAfm: INormalizedAFM): boolean {
                            return normalizedAfm.measures.some((measure) =&gt; {
                                if (isSimpleMeasure(measure)) {
                                    const filters = unwrapSimpleMeasure(measure).filters;
                                    return !!(filters &amp;&amp; filters.some(isDateFilter));
                                }
                                return false;
                            });
                        }
                        
                        /**
                         * Returns global date filters
                         *
                         * @method getGlobalDateFilters
                         * @param {INormalizedAFM} normalizedAfm
                         * @returns {AFM.DateFilterItem[]}
                         */
                        export function getGlobalDateFilters(normalizedAfm: INormalizedAFM): AFM.DateFilterItem[] {
                            return normalizedAfm.filters.filter(isDateFilter);
                        }
                        
                        /**
                         * Returns true if measure has filters
                         *
                         * @method hasFilters
                         * @param {AFM.ISimpleMeasure} measure
                         * @returns {boolean}
                         */
                        export const hasFilters = (measure: AFM.ISimpleMeasure): boolean =&gt; {
                            return !!(measure.filters &amp;&amp; measure.filters.length &gt; 0);
                        };
                        
                        /**
                         * Return date filters from AFM
                         *
                         * @method getMeasureDateFilters
                         * @param {AFM.IAfm} normalizedAfm
                         * @returns {AFM.DateFilterItem[]}
                         */
                        export function getMeasureDateFilters(normalizedAfm: AFM.IAfm): AFM.DateFilterItem[] {
                            return flatMap(normalizedAfm.measures, (item: AFM.IMeasure) =&gt; {
                                const measure = unwrapSimpleMeasure(item);
                                if (!measure || !hasFilters(measure)) {
                                    return [];
                                }
                                return (measure.filters || []).filter(isDateFilter);
                            });
                        }
                        
                        /**
                         * Return true if AFM has global date filter
                         *
                         * @method hasGlobalDateFilter
                         * @param {INormalizedAFM} afm
                         * @returns {boolean}
                         */
                        export function hasGlobalDateFilter(afm: INormalizedAFM): boolean {
                            return afm.filters.some(isDateFilter);
                        }
                        
                        function isDateFilterRelative(filter: AFM.DateFilterItem): filter is AFM.IRelativeDateFilter {
                            return filter &amp;&amp; !!(filter as AFM.IRelativeDateFilter).relativeDateFilter;
                        }
                        
                        function isDateFilterAbsolute(filter: AFM.DateFilterItem): filter is AFM.IAbsoluteDateFilter {
                            return filter &amp;&amp; !!(filter as AFM.IAbsoluteDateFilter).absoluteDateFilter;
                        }
                        
                        /**
                         * Return uri or identifier from ObjQualifier
                         *
                         * @method getId
                         * @param {AFM.ObjQualifier} obj
                         * @returns {string|null}
                         */
                        export function getId(obj: AFM.ObjQualifier): string | null {
                            if ((obj as AFM.IObjUriQualifier).uri) {
                                return (obj as AFM.IObjUriQualifier).uri;
                            }
                            if ((obj as AFM.IObjIdentifierQualifier).identifier) {
                                return (obj as AFM.IObjIdentifierQualifier).identifier;
                            }
                            return null;
                        }
                        
                        /**
                         * Returns date filter date dataset
                         *
                         * @method getDateFilterDateDataSet
                         * @param {AFM.DateFilterItem} filter
                         * @returns {AFM.ObjQualifier | null }
                         */
                        export function getDateFilterDateDataSet(filter: AFM.DateFilterItem): AFM.ObjQualifier {
                            if (isDateFilterRelative(filter)) {
                                return filter.relativeDateFilter.dataSet;
                            }
                            if (isDateFilterAbsolute(filter)) {
                                return filter.absoluteDateFilter.dataSet;
                            }
                            throw new Error(&#x27;Unsupported type of date filter&#x27;);
                        }
                        
                        /**
                         * Returns true if dateFilters dataSets match
                         *
                         * @method dateFiltersDataSetsMatch
                         * @param {AFM.DateFilterItem} f1
                         * @param {AFM.DateFilterItem} f2
                         * @returns {AFM.ObjQualifier | null | boolean}
                         */
                        export function dateFiltersDataSetsMatch(f1: AFM.DateFilterItem, f2: AFM.DateFilterItem) {
                            const d1 = getDateFilterDateDataSet(f1);
                            const d2 = getDateFilterDateDataSet(f2);
                            return d1 &amp;&amp; d2 &amp;&amp; getId(d1) === getId(d2);
                        }
                        
                        function isDateFilterAllTime(dateFilter: AFM.DateFilterItem): boolean {
                            if (dateFilter &amp;&amp; isDateFilterRelative(dateFilter)) {
                                return dateFilter.relativeDateFilter.granularity === ALL_TIME_GRANULARITY;
                            }
                            return false;
                        }
                        
                        /**
                         * Append attribute filters and date filter to afm
                         *
                         * Date filter handling:
                         *      - Override if date filter has the same id
                         *      - Add if date filter if date filter id is different
                         *
                         * Attribute filter handling:
                         *      - Add all
                         *
                         * @method appendFilters
                         * @param {AFM.IAfm} afm
                         * @param {AFM.AttributeFilterItem[]} attributeFilters
                         * @param {AFM.DateFilterItem} dateFilter
                         * @return {AFM.IAfm}
                         */
                        export function appendFilters(
                            afm: AFM.IAfm,
                            attributeFilters: AFM.AttributeFilterItem[],
                            dateFilter?: AFM.DateFilterItem
                        ): AFM.IAfm {
                            const normalizedAfm = normalizeAfm(afm);
                            const dateFilters: AFM.DateFilterItem[] = (dateFilter &amp;&amp; !isDateFilterAllTime(dateFilter)) ? [dateFilter] : [];
                            const afmDateFilter: AFM.DateFilterItem = normalizedAfm.filters.filter(isDateFilter)[0];
                        
                            // all-time selected, need to delete date filter from filters
                            let afmFilters = normalizedAfm.filters || [];
                            if (dateFilter &amp;&amp; isDateFilterAllTime(dateFilter)) {
                                afmFilters = afmFilters.filter((filter) =&gt; {
                                    if (isDateFilter(filter)) {
                                        return !dateFiltersDataSetsMatch(filter, dateFilter);
                                    }
                                    return true;
                                });
                            }
                        
                            if (
                                (afmDateFilter &amp;&amp; dateFilter &amp;&amp; !dateFiltersDataSetsMatch(afmDateFilter, dateFilter))
                                || (afmDateFilter &amp;&amp; !dateFilter)
                            ) {
                                dateFilters.push(afmDateFilter);
                            }
                        
                            const afmAttributeFilters = afmFilters.filter(filter =&gt; !isDateFilter(filter));
                        
                            const filters = compact([
                                ...afmAttributeFilters,
                                ...attributeFilters,
                                ...dateFilters
                            ]);
                        
                            return {
                                ...normalizedAfm,
                                filters
                            };
                        }
                        
                        /**
                         * Returns true if AFM is executable
                         *
                         * @method isAfmExecutable
                         * @param {AFM.IAfm} afm
                         * @returns {boolean}
                         */
                        export function isAfmExecutable(afm: AFM.IAfm) {
                            const normalizedAfm = normalizeAfm(afm);
                            return normalizedAfm.measures.length &gt; 0 || normalizedAfm.attributes.length &gt; 0;
                        }
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

